\begin{vdmpp}[breaklines=true]
class Game

instance variables
 -- the players on the game
 private players : seq of Player := [];
 -- the player that is currently making a move
 private currentPlayerID : nat1 := 1;
 -- the board of the game
 private board : [Board];
 -- invariant for game class
 -- the current player's id can never be higher than the number of players in game
 inv (len players) >= currentPlayerID;
 -- it is not possible for two different Players to have the same ID
 inv not exists m, n in seq players & m.getPlayerID() = n.getPlayerID() and m <> n;

operations
 
  -- game constructor
(*@
\label{Game:19}
@*)
  public Game : nat1 ==> Game
  Game(number) ==
  (
   if number = 2
   then players := [new Player(1,10), new Player(2,10)]
   else if number = 4 
   then players := [new Player(1,5), new Player(2,5), new Player(3,5), new Player(4,5)];
   currentPlayerID := 1;
   board := new Board(self);
   updateBoard();
  );
  
  -- sets a new position in the board for a given player
(*@
\label{move:32}
@*)
  public move: nat1 * nat1 * [Player] ==> ()
  move(new_x, new_y, player) ==
  (
   eraseOldPosition(player.getPosition());
   player.setPosition(new_x, new_y);
   updateBoard();
  )
  pre player <> nil and new_x rem 2 <> 0 and new_y rem 2 <> 0 
  post player.getPosition().getX() = new_x and player.getPosition().getY() = new_y;

  -- switches the current player to the next one
(*@
\label{switchPlayer:43}
@*)
  public switchPlayer : () ==> ()
  switchPlayer() == 
  if len players = 2
  then
  (
   if currentPlayerID = 1 then currentPlayerID := 2 
   else currentPlayerID := 1;
  )
  else if len players = 4
  then
  (
   if currentPlayerID = 1 then currentPlayerID := 2 
   else if currentPlayerID = 2 then currentPlayerID := 3
   else if currentPlayerID = 3 then currentPlayerID := 4 
   else currentPlayerID := 1;
  );
  
  -- returns the player with the specified id
(*@
\label{getPlayer:61}
@*)
  public getPlayer :nat1 ==>Player 
  getPlayer(id) ==
  return [player | player in seq players  &  player.getPlayerID() = id](1);
  
  -- returns the current player's id
(*@
\label{getCurrentPlayer:66}
@*)
  public getCurrentPlayer : () ==> nat1
  getCurrentPlayer() ==
  return currentPlayerID;
  
  -- verify wether the player won
(*@
\label{currentPlayerWin:71}
@*)
  public currentPlayerWin : () ==> bool
  currentPlayerWin() ==
  (
   if (getPlayer(currentPlayerID).getTargetRow() <> 0 and getPlayer(currentPlayerID).getPosition().getX() = getPlayer(currentPlayerID).getTargetRow()) 
     or 
    (getPlayer(currentPlayerID).getTargetCol() <> 0 and getPlayer(currentPlayerID).getPosition().getY() = getPlayer(currentPlayerID).getTargetCol())
     then return true
   else return false;  
  );
  
  -- adds a player to the players list
(*@
\label{addPlayer:82}
@*)
  public addPlayer: Player ==> ()
   addPlayer(p) ==
   (
    players := players^[p];
   )
   post len players <> 0;

  -- retrieve board from game instance
(*@
\label{getBoard:90}
@*)
  public getBoard : () ==> Board
  getBoard() == return self.board;
  
  -- retrieve players from game instance
(*@
\label{getPlayers:94}
@*)
  public getPlayers : () ==> seq of Player
  getPlayers() == return self.players;
  
  -- adds a wall to the board on the specified coordinates
(*@
\label{addWall:98}
@*)
  public addWall : nat1 * nat1 ==> bool
  addWall(row, col) == 
  (
   dcl player : Player := getPlayer(getCurrentPlayer());
   if(player.getWalls() > 0 and board.addWall(row,col))
    then return player.decWalls()
    else return false;
  )
  pre ((row mod 2 = 1) and (col mod 2 = 0)) or ((row mod 2 = 0) and (col mod 2 = 1));
  
  -- returns the possible moves for the current player
(*@
\label{getPossibleMoves:109}
@*)
  public getPossibleMoves: () ==> seq of Point
  getPossibleMoves() ==
  (
   dcl moves: seq of Point := [],
   special_moves: seq of Point := [],
   p: Player := getPlayer(currentPlayerID),
   p_x: nat1 := p.getPosition().getX(),
   p_y: nat1 := p.getPosition().getY(),
   x: nat1, y: nat1;
   
   -- upper position exists 
   if(p_x <> 1)
   then
   (
    if board.board([p_x-1,p_y]) = <NOWALL>
    then
    (
     if board.board([p_x-2,p_y]) = <FREE>
     then
     (
      x := (p_x-2);
      y := p_y;
      moves := moves^[new Point(x, y)];
     )
     else
     (
      -- jump over another player
      special_moves := special_moves^verifyPlayerJump(p_x-2, p_y, "up");
      moves := moves^special_moves;
     );
    );
   );
   -- left position exists
   if(p_y <> 1)
   then
   (
    if board.board([p_x,p_y-1]) = <NOWALL>
    then
    (
     if board.board([p_x,p_y-2]) = <FREE>
     then
     (
      x := p_x;
      y := (p_y-2);
      moves := moves^[new Point(x, y)];
     )
     else
     (
      -- jump over another player
      special_moves := special_moves^verifyPlayerJump(p_x, p_y-2, "left");
      moves := moves^special_moves;
     );
    );
   );
   -- right position exists
   if(p_y <> 17)
   then
   (
    if board.board([p_x,p_y+1]) = <NOWALL>
    then
    (
     if board.board([p_x,p_y+2]) = <FREE>
     then
     (
      x := p_x;
      y := (p_y+2);
      moves := moves^[new Point(x, y)];
     )
     else
     (
      -- jump over another player
      special_moves := special_moves^verifyPlayerJump(p_x, p_y+2, "right");
      moves := moves^special_moves;
     );
    );
   );
   -- bottom position exists
   if(p_x <> 17)
   then
   (
    if board.board([p_x+1,p_y]) = <NOWALL>
    then
    (
     if board.board([p_x+2,p_y]) = <FREE>
     then
     (
      x := (p_x+2);
      y := p_y;
      moves := moves^[new Point(x, y)];
     )
     else
     (
      -- jump over another player
      special_moves := special_moves^verifyPlayerJump(p_x+2, p_y, "down");
      moves := moves^special_moves;
     );
    );
   );
   
   return moves;
  );
  
  -- verifies whether the player can jump over another player
(*@
\label{verifyPlayerJump:212}
@*)
  public verifyPlayerJump: nat1 * nat1 * seq of char ==> seq of Point
  verifyPlayerJump(x, y, direction) ==
  (
   if board.board([x,y]) = <OCCUPIED>
   then
   (
    if direction = "up"
    then
    (
     return checkUpMove(x, y);
    )
    else
    (
     if direction = "left"
     then
     (
      return checkLeftMove(x, y);
     )
     else
     (
      if direction = "right"
      then
      (
       return checkRightMove(x, y);
      )
      else
      (
       if direction = "down"
       then
       (
        return checkDownMove(x, y);
       )
       else
       (
        return [];
       );
      );
     );
    );
   )
   else
   (
    return [];
   );
  );
  
  -- check possible up movement
(*@
\label{checkUpMove:259}
@*)
  private checkUpMove : nat1 * nat1 ==> seq of Point
  checkUpMove(x, y) ==
  (
  
   dcl special: seq of Point := [];
   
   if(x <> 1)
   then
   (
    if board.board([x-1,y]) = <NOWALL>
    then
    (
     if board.board([x-2,y]) = <FREE>
     then
     (
      special := special^[new Point(x-2, y)];
     )
    )
    -- check special case with oponent + wall followed by each other
    else
    (
     special := special^checkDiagonalHorizontal(x, y);
    );
   );
   
   return special;
    
  );
  
  -- check possible left movement
(*@
\label{checkLeftMove:289}
@*)
  private checkLeftMove : nat1 * nat1 ==> seq of Point
  checkLeftMove(x, y) ==
  (
   
   dcl special: seq of Point := [];
   
   if(y <> 1)
   then
   (
    if board.board([x,y-1]) = <NOWALL>
    then
    (
     if board.board([x,y-2]) = <FREE>
     then
     (
      special := special^[new Point(x, y-2)];
     )
    )
    -- check special case with oponent + wall followed by each other
    else
    (
     special := special^checkDiagonalVertical(x, y);
    );
   );
   
   return special;
   
  );
  
  -- check possible right movement
(*@
\label{checkRightMove:319}
@*)
  private checkRightMove : nat1 * nat1 ==> seq of Point
  checkRightMove(x, y) ==
  ( 
  
   dcl special: seq of Point := [];
   
   if(y <> 17)
   then
   (
    if board.board([x,y+1]) = <NOWALL>
    then
    (
     if board.board([x,y+2]) = <FREE>
     then
     (
      special := special^[new Point(x, y+2)];
     )
    )
    -- check special case with oponent + wall followed by each other
    else
    (
     special := special^checkDiagonalVertical(x, y);
    );
   );
   
   return special;
   
  );
  
  -- check possible down movement
(*@
\label{checkDownMove:349}
@*)
  private checkDownMove : nat1 * nat1 ==> seq of Point
  checkDownMove(x, y) ==
  (
  
   dcl special: seq of Point := [];
  
   if(x <> 17)
   then
   (
    if board.board([x+1,y]) = <NOWALL>
    then
    (
     if board.board([x+2,y]) = <FREE>
     then
     (
      special := special^[new Point(x+2, y)];
     )
    )
    -- check special case with oponent + wall followed by each other
    else
    (
     special := special^checkDiagonalHorizontal(x, y);
    );
   );
   
   return special;
   
  );
  
  -- check diagonal movement direction horizontal in special cases
(*@
\label{checkDiagonalHorizontal:379}
@*)
  private checkDiagonalHorizontal : nat1 * nat1 ==> seq of Point
  checkDiagonalHorizontal(x, y) ==
  (
  
   dcl special: seq of Point := [];
   
   -- check if the movement to the left is possible
   if y <> 1
   then
   (
    -- check for walls on the left
    if board.board([x,y-1]) = <NOWALL>
    then
    (
     if board.board([x,y-2]) = <FREE>
     then
     (
      special := special^[new Point(x, y-2)];
     )
    );
   );
   -- check if the movement to the right is possible
   if y <> 17
   then
   (
    -- check for walls on the right
    if board.board([x,y+1]) = <NOWALL>
    then
    (
     if board.board([x,y+2]) = <FREE>
     then
     (
      special := special^[new Point(x, y+2)];
     )
    );
   );
   
   return special;
   
  );
  
  -- check diagonal movement direction vertical in special cases
(*@
\label{checkDiagonalVertical:421}
@*)
  private checkDiagonalVertical : nat1 * nat1 ==> seq of Point
  checkDiagonalVertical(x, y) ==
  (
  
   dcl special: seq of Point := [];
   
   -- check if the movement up is possible
   if x <> 1
   then
   (
    -- check for walls up
    if board.board([x-1,y]) = <NOWALL>
    then
    (
     if board.board([x-2,y]) = <FREE>
     then
     (
      special := special^[new Point(x-2, y)];
     )
    );
   );
   -- check if the movement down is possible
   if x <> 17
   then
   (
    -- check for walls down
    if board.board([x+1,y]) = <NOWALL>
    then
    (
     if board.board([x+2,y]) = <FREE>
     then
     (
      special := special^[new Point(x+2, y)];
     )
    );
   );
  
   return special;
   
  );
  
  -- update board according to player's positions
(*@
\label{updateBoard:463}
@*)
  public updateBoard : () ==> () 
  updateBoard() ==
  (
   if(len players = 2) 
   then (
    dcl player1: Player := getPlayer(1),
    player2: Player := getPlayer(2),
    p1_position: Point := player1.getPosition(),
    p2_position: Point := player2.getPosition();
    
    board.setBoardPosition(p1_position);
    board.setBoardPosition(p2_position);
   )
   else if(len players = 4)
   then (
    dcl player1: Player := getPlayer(1),
    player2: Player := getPlayer(2),
    player3: Player := getPlayer(3),
    player4: Player := getPlayer(4),
    p1_position: Point := player1.getPosition(),
    p2_position: Point := player2.getPosition(),
    p3_position: Point := player3.getPosition(),
    p4_position: Point := player4.getPosition();
    
    board.setBoardPosition(p1_position);
    board.setBoardPosition(p2_position);
    board.setBoardPosition(p3_position);
    board.setBoardPosition(p4_position);
   );
  );
  
  -- update board by erasing the old player's position
(*@
\label{eraseOldPosition:495}
@*)
  public eraseOldPosition : Point ==> ()
  eraseOldPosition(old_position) ==
  (
   board.unsetBoardPosition(old_position);
  );

end Game
\end{vdmpp}
\bigskip
\begin{longtable}{|l|r|r|r|}
\hline
Function or operation & Line & Coverage & Calls \\
\hline
\hline
\hyperref[Game:19]{Game} & 19&100.0\% & 36 \\
\hline
\hyperref[addPlayer:82]{addPlayer} & 82&100.0\% & 4 \\
\hline
\hyperref[addWall:98]{addWall} & 98&100.0\% & 20 \\
\hline
\hyperref[checkDiagonalHorizontal:379]{checkDiagonalHorizontal} & 379&100.0\% & 8 \\
\hline
\hyperref[checkDiagonalVertical:421]{checkDiagonalVertical} & 421&100.0\% & 8 \\
\hline
\hyperref[checkDownMove:349]{checkDownMove} & 349&100.0\% & 12 \\
\hline
\hyperref[checkLeftMove:289]{checkLeftMove} & 289&100.0\% & 8 \\
\hline
\hyperref[checkRightMove:319]{checkRightMove} & 319&100.0\% & 8 \\
\hline
\hyperref[checkUpMove:259]{checkUpMove} & 259&100.0\% & 13 \\
\hline
\hyperref[currentPlayerWin:71]{currentPlayerWin} & 71&100.0\% & 12 \\
\hline
\hyperref[eraseOldPosition:495]{eraseOldPosition} & 495&100.0\% & 72 \\
\hline
\hyperref[getBoard:90]{getBoard} & 90&100.0\% & 12 \\
\hline
\hyperref[getCurrentPlayer:66]{getCurrentPlayer} & 66&100.0\% & 48 \\
\hline
\hyperref[getPlayer:61]{getPlayer} & 61&100.0\% & 416 \\
\hline
\hyperref[getPlayers:94]{getPlayers} & 94&100.0\% & 88 \\
\hline
\hyperref[getPossibleMoves:109]{getPossibleMoves} & 109&100.0\% & 40 \\
\hline
\hyperref[move:32]{move} & 32&100.0\% & 68 \\
\hline
\hyperref[switchPlayer:43]{switchPlayer} & 43&100.0\% & 36 \\
\hline
\hyperref[updateBoard:463]{updateBoard} & 463&100.0\% & 104 \\
\hline
\hyperref[verifyPlayerJump:212]{verifyPlayerJump} & 212&100.0\% & 46 \\
\hline
\hline
Game.vdmpp & & 100.0\% & 1059 \\
\hline
\end{longtable}

