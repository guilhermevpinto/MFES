class Board
	types
	
		-- type representing each area segment of the board
		public Slot = <FREE> | <VISITED> | <WALL> | <NOWALL>;
		
	values

	instance variables
	
		-- the representation of the board
		public static board : seq of seq of Slot := [
				[<FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>],
				[<NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>],
				[<FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>],
				[<NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>],
				[<FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>],
				[<NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>],
				[<FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>],
				[<NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>],
				[<FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>],
				[<NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>],
				[<FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>],
				[<NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>],
				[<FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>],
				[<NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>],
				[<FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>],
				[<NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>],
				[<FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>]
			];
		-- an auxiliary board to validate logical plays (droping walls)
		private conectivity : seq of seq of Slot;
		
	
	operations
	
		-- constructor
		public Board : () ==> Board
		Board() == 
		(
			conectivity := board;
		)
		post conectivity = board;
		
		-- resets the auxiliar board with the current board status to future path processing, 
		public resetConectivity : () ==> ()
		resetConectivity() == 
		(
			conectivity := board;
		)
		post conectivity = board;
		
		-- adds a new wall to the board, if possible
		public addWall : nat1 * nat1 ==> ()
		addWall(row, col) == 
		(
			resetConectivity();
			if row mod 2 = 1
				then 
				(
					if col < 18 and row < 16 and board(row)(col) = <NOWALL> and board(row+1)(col) = <NOWALL> and board(row+2)(col) = <NOWALL>
						then
						(
							conectivity(row) := conectivity(row) ++ {col |-> <WALL>};
							conectivity(row+1) := conectivity(row+1) ++ {col |-> <WALL>};
							conectivity(row+2) := conectivity(row+2) ++ {col |-> <WALL>};
							if pathToDestination(17, 3,1)
							then
							(
								board(row) := board(row) ++ {col |-> <WALL>};
								board(row+1) := board(row+1) ++ {col |-> <WALL>};
								board(row+2) := board(row+2) ++ {col |-> <WALL>};
							)
							else
							(
								conectivity(row) := conectivity(row) ++ {col |-> <NOWALL>};
								conectivity(row+1) := conectivity(row+1) ++ {col |-> <NOWALL>};
								conectivity(row+2) := conectivity(row+2) ++ {col |-> <NOWALL>};
							);
						)
				)
				else
				(
					if col < 16 and row < 18 and board(row)(col) = <NOWALL> and board(row)(col+1) = <NOWALL> and board(row)(col+2) = <NOWALL>
						then
						(
							conectivity(row) := conectivity(row) ++ {col |-> <WALL>, col+1 |-> <WALL>, col+2 |-> <WALL>};
							if pathToDestination(17, 3,1)
							then
							(
								board(row) := board(row) ++ {col |-> <WALL>, col+1 |-> <WALL>, col+2 |-> <WALL>};
							)
							else
							(
								conectivity(row) := conectivity(row) ++ {col |-> <NOWALL>, col+1 |-> <NOWALL>, col+2 |-> <NOWALL>};
							);
						)
				)
		)
		pre row >= 1 and row <= 17 and col >= 1 and col <= 17;
		
		private pathToDestination : nat1 * nat1 * nat1 ==> bool
		pathToDestination(rowDest, row, col) ==
		(
			if row = rowDest
				then return true;
				
			if conectivity(row)(col) <> <FREE>
				then return false;
			
			conectivity(row) := conectivity(row) ++ {col |-> <VISITED>};
		
			if row = 1
			then
			(
				if col = 1
					then return checkRight(rowDest, row, col + 1) or checkDown(rowDest, row + 1, col)
				else if col = 17
					then return checkLeft(rowDest, row, col - 1) or checkDown(rowDest, row + 1, col)
				else return checkLeft(rowDest, row, col - 1) or checkRight(rowDest, row, col + 1) or checkDown(rowDest, row + 1, col)
			);
			
			if row = 17
			then
			(
				if col = 1
					then return checkRight(rowDest, row, col + 1) or checkUp(rowDest, row - 1, col)
				else if col = 17
					then return checkLeft(rowDest, row, col - 1) or checkUp(rowDest, row - 1, col)
				else return checkLeft(rowDest, row, col - 1) or checkRight(rowDest, row, col + 1) or checkUp(rowDest, row - 1, col)
			);
			
			if col = 1
			then return checkRight(rowDest, row, col + 1) or checkUp(rowDest, row - 1, col) or checkDown(rowDest, row + 1, col)
			else if col = 17
			then return checkLeft(rowDest, row, col - 1) or checkUp(rowDest, row - 1, col) or checkDown(rowDest, row + 1, col)
			else return checkLeft(rowDest, row, col - 1) or checkRight(rowDest, row, col + 1) or checkUp(rowDest, row - 1, col) or checkDown(rowDest, row + 1, col);
		)
		pre (rowDest = 1 or rowDest = 17) and row mod 2 = 1 and col mod 2 = 1 and row >= 1 and col >= 1 and row <= 17 and col <> 17;
		
		private checkDown : nat1 * nat1 * nat1 ==> bool
		checkDown(rowDest, row, col) ==
		(
			if conectivity(row)(col) <> <WALL>
				then return pathToDestination(rowDest, row + 1, col)
			else return false;
		);
		
		private checkUp : nat1 * nat1 * nat1 ==> bool
		checkUp(rowDest, row, col) ==
		(
			if conectivity(row)(col) <> <WALL>
				then return pathToDestination(rowDest, row - 1, col)
			else return false;
		);
		
		private checkRight : nat1 * nat1 * nat1 ==> bool
		checkRight(rowDest, row, col) ==
		(
			if conectivity(row)(col) <> <WALL>
				then return pathToDestination(rowDest, row, col + 1)
			else return false;
		);
		
		private checkLeft : nat1 * nat1 * nat1 ==> bool
		checkLeft(rowDest, row, col) ==
		(
			if conectivity(row)(col) <> <WALL>
				then return pathToDestination(rowDest, row, col - 1)
			else return false;
		);
		
functions
	
	
traces
-- TODO Define Combinatorial Test Traces here		
end Board