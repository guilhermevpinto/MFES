class Board
	types
	
		-- type representing each area segment of the board
		public Slot = <FREE> | <OCCUPIED> | <VISITED> | <WALL> | <NOWALL>;

	instance variables
	
		private game : Game;
	
		-- the representation of the board
		public static board : seq of seq of Slot := [
				[<FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>],
				[<NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>],
				[<FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>],
				[<NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>],
				[<FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>],
				[<NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>],
				[<FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>],
				[<NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>],
				[<FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>],
				[<NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>],
				[<FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>],
				[<NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>],
				[<FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>],
				[<NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>],
				[<FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>],
				[<NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>],
				[<FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>]
			];
			
		-- an auxiliary board to validate logical plays (droping walls)
		public conectivity : seq of seq of Slot;
		
	
	operations
	
		-- constructor
		public Board : Game ==> Board
		Board(gameObj) == 
		(
			conectivity := board;
			game := gameObj;
		)
		post conectivity = board;
		
		-- resets the auxiliar board with the current board status to future path processing, 
		public resetConectivity : () ==> bool
		resetConectivity() == 
		(
			conectivity := board;
			return true;
		)
		post conectivity = board;
		
		-- adds a new wall to the board, if possible
		public addWall : nat1 * nat1 * seq of Player ==> [bool]
		addWall(row, col, players) == 
		(
			if row mod 2 = 1
			then 
			(
				if col < 18 and row < 16 and board(row)(col) = <NOWALL> and board(row+1)(col) = <NOWALL> and board(row+2)(col) = <NOWALL>
				then
				(
					board(row) := board(row) ++ {col |-> <WALL>};
					board(row+1) := board(row+1) ++ {col |-> <WALL>};
					board(row+2) := board(row+2) ++ {col |-> <WALL>};
					
					if exists1 p in seq players & resetConectivity() and not pathToDestination(p, p.getPosition().getX() , p.getPosition().getY())
					then
					(
						board(row) := board(row) ++ {col |-> <NOWALL>};
						board(row+1) := board(row+1) ++ {col |-> <NOWALL>};
						board(row+2) := board(row+2) ++ {col |-> <NOWALL>};
						return false;
					)
					else return true;
				)
				else return false;
			)
			else
			(
				if col < 16 and row < 18 and board(row)(col) = <NOWALL> and board(row)(col+1) = <NOWALL> and board(row)(col+2) = <NOWALL>
				then
				(
					board(row) := board(row) ++ {col |-> <WALL>, col+1 |-> <WALL>, col+2 |-> <WALL>};
					
					if exists1 p in seq players & resetConectivity() and not pathToDestination(p, p.getPosition().getX() , p.getPosition().getY())
					then
					(
						board(row) := board(row) ++ {col |-> <NOWALL>, col+1 |-> <NOWALL>, col+2 |-> <NOWALL>};
						return false;
					)
					else return true;
				)
				else return false;
			)
		)
		pre row >= 1 and row <= 17 and col >= 1 and col <= 17;
		
		private pathToDestination : Player * nat1 * nat1 ==> bool
		pathToDestination(p, row, col) ==
		(
			if p.getTargetRow() <> nil and p.getTargetRow() = row
				then return true
			else if p.getTargetCol() <> nil and p.getTargetCol() = col
				then return true;
				
			if conectivity(row)(col) = <VISITED>
				then return false;
			
			conectivity(row) := conectivity(row) ++ {col |-> <VISITED>};
		
			if row = 1
			then
			(
				if col = 1
					then return checkRight(p, row, col + 1) or checkDown(p, row + 1, col)
				else if col = 17
					then return checkLeft(p, row, col - 1) or checkDown(p, row + 1, col)
				else return checkLeft(p, row, col - 1) or checkRight(p, row, col + 1) or checkDown(p, row + 1, col)
			);
			
			if row = 17
			then
			(
				if col = 1
					then return checkRight(p, row, col + 1) or checkUp(p, row - 1, col)
				else if col = 17
					then return checkLeft(p, row, col - 1) or checkUp(p, row - 1, col)
				else return checkLeft(p, row, col - 1) or checkRight(p, row, col + 1) or checkUp(p, row - 1, col)
			);
			
			if col = 1
			then return checkRight(p, row, col + 1) or checkUp(p, row - 1, col) or checkDown(p, row + 1, col)
			else if col = 17
			then return checkLeft(p, row, col - 1) or checkUp(p, row - 1, col) or checkDown(p, row + 1, col)
			else return checkLeft(p, row, col - 1) or checkRight(p, row, col + 1) or checkUp(p, row - 1, col) or checkDown(p, row + 1, col);
		)
		pre (p.getTargetRow() <> nil or p.getTargetCol() <> nil) and row mod 2 = 1 and col mod 2 = 1 and row >= 1 and col >= 1 and row <= 17 and col <= 17;
		
		private checkDown : Player * nat1 * nat1 ==> bool
		checkDown(p, row, col) ==
		(
			if conectivity(row)(col) <> <WALL>
				then return pathToDestination(p, row + 1, col)
			else return false;
		);
		
		private checkUp : Player * nat1 * nat1 ==> bool
		checkUp(p, row, col) ==
		(
			if conectivity(row)(col) <> <WALL>
				then return pathToDestination(p, row - 1, col)
			else return false;
		);
		
		private checkRight : Player * nat1 * nat1 ==> bool
		checkRight(p, row, col) ==
		(
			if conectivity(row)(col) <> <WALL>
				then return pathToDestination(p, row, col + 1)
			else return false;
		);
		
		private checkLeft : Player * nat1 * nat1 ==> bool
		checkLeft(p, row, col) ==
		(
			if conectivity(row)(col) <> <WALL>
				then return pathToDestination(p, row, col - 1)
			else return false;
		);
		
		-- Sets the board position as occupied
		public setBoardPosition: Point ==> () 
		setBoardPosition(p) ==
		(
			board(p.getX()) := board(p.getX()) ++ {p.getY() |-> <OCCUPIED>};
		);
		
		-- Sets the occupied board cell back to free
		public unsetBoardPosition: Point ==> ()
		unsetBoardPosition(p) ==
		(
			board(p.getX()) := board(p.getX()) ++ {p.getY() |-> <FREE>}; 
		);
		
		
		public dropableWall: nat1 * nat1 ==> [seq of nat1]
		dropableWall(row, col) == 
		(
			if (col mod 2) = 0
			then
			(
				if (board(row)(col) = <NOWALL> and board(row+1)(col) = <NOWALL> and board(row+2)(col) = <NOWALL>)
				then return [row+2,col];
			)
			else if (row mod 2) = 0
			then
			(
				if (board(row)(col) = <NOWALL> and board(row)(col+1) = <NOWALL> and board(row)(col+2) = <NOWALL>)
				then return [row,col+2];
			);
			
			return nil;
		);
functions
			
	
traces
-- TODO Define Combinatorial Test Traces here		
end Board