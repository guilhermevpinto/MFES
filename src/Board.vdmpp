class Board
	types
	
		-- type representing each area segment of the board
		public Slot = <FREE> | <OCCUPIED> | <VISITED> | <WALL> | <NOWALL>;

	instance variables
	
		-- the game instance
		private game : Game;
	
		-- the representation of the board
		public static board : seq of seq of Slot := [
				[<FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>],
				[<NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>],
				[<FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>],
				[<NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>],
				[<FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>],
				[<NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>],
				[<FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>],
				[<NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>],
				[<FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>],
				[<NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>],
				[<FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>],
				[<NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>],
				[<FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>],
				[<NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>],
				[<FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>],
				[<NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>, <NOWALL>],
				[<FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>, <NOWALL>, <FREE>]
			];
			
		-- an auxiliary board to validate logical plays (droping walls)
		public conectivity : seq of seq of Slot;
		
	
	operations
	
		-- constructor
		public Board : Game ==> Board
		Board(gameObj) == 
		(
			conectivity := board;
			game := gameObj;
		)
		post conectivity = board;
		
		-- resets the auxiliar board with the current board status to future path processing
		public resetConectivity : () ==> bool
		resetConectivity() == 
		(
			conectivity := board;
			return true;
		)
		post conectivity = board;
		
		-- adds a new wall to the board, if possible
		public addWall : nat1 * nat1 * seq of Player ==> [bool]
		addWall(row, col, players) == 
		(
			dcl oneRow : int := row + 1;
			dcl twoRow : int := row + 2;
			dcl oneCol : int := col + 1;
			dcl twoCol : int := col + 2;
			if row mod 2 = 1
			then 
			(
				if col < 18 and row < 16 and board(row)(col) = <NOWALL> and board(oneRow)(col) = <NOWALL> and board(oneRow)(col) = <NOWALL>
				then
				(
					dcl first : seq of Slot := board(row) ++ {col |-> <WALL>};
					dcl second : seq of Slot := board(oneRow) ++ {col |-> <WALL>};
					dcl third : seq of Slot := board(twoRow) ++ {col |-> <WALL>};
					
					board := board ++ {row |-> first , oneRow |-> second, twoRow |-> third};
					
					if exists1 p in seq players & resetConectivity() and not pathToDestination(p, p.getPosition().getX() , p.getPosition().getY())
					then
					(
						dcl first2 : seq of Slot := board(row) ++ {col |-> <NOWALL>};
						dcl second2 : seq of Slot := board(oneRow) ++ {col |-> <NOWALL>};
						dcl third2 : seq of Slot := board(twoRow) ++ {col |-> <NOWALL>};
						
						board := board ++ {row |-> first2 , oneRow |-> second2, twoRow |-> third2};
						return false;
					)
					else return true;
				)
				else return false;
			)
			else
			(
				if col < 16 and row < 18 and board(row)(col) = <NOWALL> and board(row)(oneCol) = <NOWALL> and board(row)(twoCol) = <NOWALL>
				then
				(
					dcl first : seq of Slot := board(row) ++ {col |-> <WALL>, oneCol |-> <WALL>, twoCol |-> <WALL>};
					
					board := board ++ {row |-> first};
					
					if exists1 p in seq players & resetConectivity() and not pathToDestination(p, p.getPosition().getX() , p.getPosition().getY())
					then
					(
						dcl first2 : seq of Slot := board(row) ++ {col |-> <NOWALL>, oneCol |-> <NOWALL>, twoCol |-> <NOWALL>};
					
						board := board ++ {row |-> first2};
						return false;
					)
					else return true;
				)
				else return false;
			)
		)
		pre row >= 1 and row <= 17 and col >= 1 and col <= 17;
		
		-- checks whether the player can get to the target row or not
		private pathToDestination : Player * nat1 * nat1 ==> bool
		pathToDestination(p, row, col) ==
		(
			if p.getTargetRow() <> nil and p.getTargetRow() = row
				then return true
			else if p.getTargetCol() <> nil and p.getTargetCol() = col
				then return true;
				
			if conectivity(row)(col) = <VISITED>
				then return false;
			
			conectivity(row) := conectivity(row) ++ {col |-> <VISITED>};
		
			if row = 1
			then
			(
				if col = 1
					then return checkRight(p, row, col + 1) or checkDown(p, row + 1, col)
				else if col = 17
					then return checkLeft(p, row, col - 1) or checkDown(p, row + 1, col)
				else return checkLeft(p, row, col - 1) or checkRight(p, row, col + 1) or checkDown(p, row + 1, col)
			);
			
			if row = 17
			then
			(
				if col = 1
					then return checkRight(p, row, col + 1) or checkUp(p, row - 1, col)
				else if col = 17
					then return checkLeft(p, row, col - 1) or checkUp(p, row - 1, col)
				else return checkLeft(p, row, col - 1) or checkRight(p, row, col + 1) or checkUp(p, row - 1, col)
			);
			
			if col = 1
			then return checkRight(p, row, col + 1) or checkUp(p, row - 1, col) or checkDown(p, row + 1, col)
			else if col = 17
			then return checkLeft(p, row, col - 1) or checkUp(p, row - 1, col) or checkDown(p, row + 1, col)
			else return checkLeft(p, row, col - 1) or checkRight(p, row, col + 1) or checkUp(p, row - 1, col) or checkDown(p, row + 1, col);
		)
		pre (p.getTargetRow() <> nil or p.getTargetCol() <> nil) and row mod 2 = 1 and col mod 2 = 1 and row >= 1 and col >= 1 and row <= 17 and col <= 17;
		
		-- checks path availability on the direction down
		private checkDown : Player * nat1 * nat1 ==> bool
		checkDown(p, row, col) ==
		(
			if conectivity(row)(col) <> <WALL>
				then return pathToDestination(p, row + 1, col)
			else return false;
		);
		
		-- checks path availability on the direction up
		private checkUp : Player * nat1 * nat1 ==> bool
		checkUp(p, row, col) ==
		(
			if conectivity(row)(col) <> <WALL>
				then return pathToDestination(p, row - 1, col)
			else return false;
		);
		
		-- checks path availability on the direction right
		private checkRight : Player * nat1 * nat1 ==> bool
		checkRight(p, row, col) ==
		(
			if conectivity(row)(col) <> <WALL>
				then return pathToDestination(p, row, col + 1)
			else return false;
		);
		
		-- checks path availability on the direction left
		private checkLeft : Player * nat1 * nat1 ==> bool
		checkLeft(p, row, col) ==
		(
			if conectivity(row)(col) <> <WALL>
				then return pathToDestination(p, row, col - 1)
			else return false;
		);
		
		-- Sets the board position as occupied
		public setBoardPosition: Point ==> () 
		setBoardPosition(p) ==
		(
			board(p.getX()) := board(p.getX()) ++ {p.getY() |-> <OCCUPIED>};
		);
		
		-- Sets the occupied board cell back to free
		public unsetBoardPosition: Point ==> ()
		unsetBoardPosition(p) ==
		(
			board(p.getX()) := board(p.getX()) ++ {p.getY() |-> <FREE>}; 
		);
		
		-- remove a wall
		public dropableWall: nat1 * nat1 ==> [seq of nat1]
		dropableWall(row, col) == 
		(
			if (col mod 2) = 0
			then
			(
				if (board(row)(col) = <NOWALL> and board(row+1)(col) = <NOWALL> and board(row+2)(col) = <NOWALL>)
				then return [row+2,col];
			)
			else if (row mod 2) = 0
			then
			(
				if (board(row)(col) = <NOWALL> and board(row)(col+1) = <NOWALL> and board(row)(col+2) = <NOWALL>)
				then return [row,col+2];
			);
			
			return nil;
		);
functions
			
	
traces
-- TODO Define Combinatorial Test Traces here		
end Board